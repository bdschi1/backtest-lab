"""Markdown tear sheet — same content as the HTML tearsheet, with PNG charts.

Generates a .md file with embedded chart references (PNGs saved alongside).
Opens in any markdown viewer (VS Code, GitHub, Obsidian, etc.).

Usage:
    from reports.markdown_tearsheet import generate_markdown_tearsheet
    engine.run(prices)
    generate_markdown_tearsheet(engine, output_dir="results/run_001/", output_path="results/run_001/tearsheet.md")
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Any

import numpy as np

logger = logging.getLogger(__name__)


def generate_markdown_tearsheet(
    engine: Any,
    output_dir: str,
    output_path: str = "tearsheet.md",
    title: str | None = None,
    data_source_info: dict | None = None,
) -> str:
    """Generate a markdown tear sheet from a completed backtest engine.

    Args:
        engine: BacktestEngine instance (must have been run).
        output_dir: Directory for PNG chart files.
        output_path: Where to save the markdown file.
        title: Optional title (defaults to signal name).
        data_source_info: Optional dict with data provenance.

    Returns:
        Path to the generated markdown file.
    """
    from reports.charts import (
        plot_drawdown,
        plot_equity_curve,
        plot_monthly_heatmap,
        plot_regime_timeline,
        plot_rolling_sharpe,
    )
    from reports.tearsheet import (
        _compute_drawdowns,
        _compute_monthly_returns,
        _rolling_sharpe,
    )

    if not engine.snapshots:
        raise ValueError("Engine has no snapshots — did you call engine.run()?")

    summary = engine.summary()
    title = title or f"Backtest: {summary.get('signal_name', 'Unknown Signal')}"

    # Extract data series
    dates = [s.date.isoformat() for s in engine.snapshots]
    equity = [s.equity for s in engine.snapshots]
    returns = [s.daily_return for s in engine.snapshots]
    drawdowns = _compute_drawdowns(equity)
    regimes = [s.regime for s in engine.snapshots]
    monthly = _compute_monthly_returns(engine.snapshots)
    rolling_sharpe = _rolling_sharpe(returns, window=63)

    # Generate charts
    out = Path(output_dir)
    out.mkdir(parents=True, exist_ok=True)

    plot_equity_curve(dates, equity, str(out / "equity_curve.png"))
    plot_drawdown(dates, drawdowns, str(out / "drawdown.png"))
    plot_rolling_sharpe(dates, rolling_sharpe, str(out / "rolling_sharpe.png"))
    plot_monthly_heatmap(monthly, str(out / "monthly_returns.png"))

    has_regime = any(r is not None for r in regimes)
    if has_regime:
        plot_regime_timeline(dates, regimes, str(out / "regime_timeline.png"))

    # Build markdown
    parts = [
        f"# {title}\n",
        f"*Generated by backtest-lab*\n",
        _data_source_line(data_source_info),
        _summary_section(summary),
        _benchmark_section(summary),
        _risk_decomposition_section(summary),
        "\n## Equity Curve\n",
        "![Equity Curve](equity_curve.png)\n",
        "\n## Drawdown\n",
        "![Drawdown](drawdown.png)\n",
        "\n## Rolling Sharpe (63-day)\n",
        "![Rolling Sharpe](rolling_sharpe.png)\n",
        _monthly_returns_section(monthly),
    ]

    if has_regime:
        parts.append("\n## Market Regime\n")
        parts.append("![Regime Timeline](regime_timeline.png)\n")

    parts.append(_cost_breakdown_section(summary))
    parts.append(_trade_log_section(engine.trades))
    parts.append("\n---\n*backtest-lab tear sheet*\n")

    md_content = "\n".join(parts)

    md_path = Path(output_path)
    md_path.parent.mkdir(parents=True, exist_ok=True)
    md_path.write_text(md_content, encoding="utf-8")

    logger.info("Markdown tear sheet saved to %s", md_path)
    return str(md_path)


# ---------------------------------------------------------------------------
# Section generators
# ---------------------------------------------------------------------------

def _data_source_line(info: dict | None) -> str:
    """Build data source provenance line for markdown."""
    if not info:
        return ""

    provider = info.get("data_provider", "Unknown")
    freq = info.get("data_frequency", "daily")
    start = info.get("data_start", "")
    end = info.get("data_end", "")
    resolved = info.get("data_tickers_resolved", 0)
    requested = info.get("data_tickers_requested", 0)

    parts = [f"**Data:** {provider} ({freq})"]
    if start and end:
        parts.append(f"{start} → {end}")
    if requested:
        parts.append(f"{resolved}/{requested} tickers resolved")

    return "> " + " | ".join(parts) + "\n"


def _summary_section(s: dict) -> str:
    """Build summary stats as markdown table."""

    def _fmt(key, fmt_str, suffix=""):
        val = s.get(key, 0)
        return f"{val:{fmt_str}}{suffix}"

    rows = [
        "## Summary\n",
        "| Metric | Value |",
        "|--------|-------|",
        f"| Total Return | {_fmt('total_return_pct', '+.2f')}% |",
        f"| Ann. Return | {_fmt('annualized_return_pct', '+.2f')}% |",
        f"| Sharpe | {_fmt('sharpe_ratio', '.2f')} |",
        f"| Sortino | {_fmt('sortino_ratio', '.2f')} |",
        f"| Max DD | {_fmt('max_drawdown_pct', '.2f')}% |",
        f"| Calmar | {_fmt('calmar_ratio', '.2f')} |",
        f"| Ann. Vol | {_fmt('annualized_vol_pct', '.2f')}% |",
        f"| Total Trades | {s.get('total_trades', 0):,} |",
        f"| Total Costs | ${s.get('total_costs', 0):,.2f} |",
        f"| Stops Triggered | {s.get('total_stops_triggered', 0)} |",
        f"| Trades Rejected | {s.get('total_trades_rejected', 0)} |",
        f"| Risk Manager | {s.get('risk_manager', 'OFF')} |",
        f"| Win Rate | {_fmt('win_rate', '.1f')}% |",
        f"| Slugging Pct | {_fmt('slugging_pct', '.2f')} |",
        f"| Profit Factor | {_fmt('profit_factor', '.2f')} |",
        f"| Avg Win | ${s.get('avg_win', 0):,.0f} |",
        f"| Avg Loss | ${s.get('avg_loss', 0):,.0f} |",
        f"| Best Trade | ${s.get('best_trade', 0):,.0f} |",
        f"| Worst Trade | ${s.get('worst_trade', 0):,.0f} |",
        f"| Max DD Duration | {s.get('max_dd_duration_days', 0)} days |",
        f"| Max DD Recovery | {s.get('max_dd_recovery_days', 0)} days |",
    ]
    return "\n".join(rows)


def _benchmark_section(s: dict) -> str:
    """Build benchmark comparison as markdown table."""
    if "beta" not in s:
        return ""

    rows = [
        "\n## Benchmark Comparison (SPY)\n",
        "| Metric | Value |",
        "|--------|-------|",
        f"| Benchmark Return | {s.get('benchmark_return_pct', 0):+.2f}% |",
        f"| Relative Return | {s.get('relative_return_pct', 0):+.2f}% |",
        f"| Beta | {s.get('beta', 0):.3f} |",
        f"| Alpha | {s.get('alpha_pct', 0):+.2f}% |",
        f"| Information Ratio | {s.get('information_ratio', 0):.3f} |",
        f"| Tracking Error | {s.get('tracking_error_pct', 0):.2f}% |",
        f"| Up Capture | {s.get('up_capture_pct', 0):.1f}% |",
        f"| Down Capture | {s.get('down_capture_pct', 0):.1f}% |",
        f"| Correlation | {s.get('benchmark_correlation', 0):.3f} |",
    ]
    return "\n".join(rows)


def _risk_decomposition_section(s: dict) -> str:
    """Build risk decomposition as markdown table."""
    if "risk_ann_vol_pct" not in s:
        return ""

    rows = [
        "\n## Risk Decomposition\n",
        "| Metric | Value |",
        "|--------|-------|",
        f"| Ann. Vol | {s.get('risk_ann_vol_pct', 0):.2f}% |",
        f"| Downside Vol | {s.get('risk_downside_vol_pct', 0):.2f}% |",
        f"| 21d Rolling Vol | {s.get('risk_vol_21d_current_pct', 0):.2f}% |",
        f"| 63d Rolling Vol | {s.get('risk_vol_63d_current_pct', 0):.2f}% |",
        f"| Avg Gross Exposure | {s.get('risk_avg_gross_exposure_pct', 0):.1f}% |",
        f"| Avg Net Exposure | {s.get('risk_avg_net_exposure_pct', 0):+.1f}% |",
        f"| Final Gross Exposure | {s.get('risk_final_gross_pct', 0):.1f}% |",
        f"| Final Net Exposure | {s.get('risk_final_net_pct', 0):+.1f}% |",
        f"| HHI (Concentration) | {s.get('risk_hhi', 0):.4f} |",
        f"| Top 1 Name | {s.get('risk_top1_pct', 0):.1f}% |",
        f"| Top 5 Names | {s.get('risk_top5_pct', 0):.1f}% |",
        f"| Avg Positions | {s.get('risk_avg_positions', 0):.1f} |",
    ]

    beta = s.get("risk_portfolio_beta")
    if beta is not None:
        rows.extend([
            f"| Portfolio Beta | {beta:.3f} |",
            f"| Beta P&L | {s.get('risk_beta_pnl_pct', 0):+.2f}% |",
            f"| Alpha P&L | {s.get('risk_alpha_pnl_pct', 0):+.2f}% |",
            f"| Idiosyncratic Ratio | {s.get('risk_idio_ratio_pct', 0):.1f}% |",
        ])
        if s.get("risk_idio_vol_pct") is not None:
            rows.append(f"| Idio Vol | {s.get('risk_idio_vol_pct', 0):.2f}% |")
        if s.get("risk_idio_sharpe") is not None:
            rows.append(f"| Idio Sharpe | {s.get('risk_idio_sharpe', 0):.3f} |")

    return "\n".join(rows)


def _monthly_returns_section(monthly: dict[tuple[int, int], float]) -> str:
    """Build monthly returns as markdown table + heatmap image."""
    if not monthly:
        return ""

    parts = [
        "\n## Monthly Returns\n",
        "![Monthly Returns](monthly_returns.png)\n",
    ]

    # Also include raw numbers as a table
    years = sorted(set(y for y, m in monthly))
    month_names = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

    header = "| Year | " + " | ".join(month_names) + " | Annual |"
    sep = "|------|" + "|".join(["------"] * 12) + "|--------|"
    parts.append(header)
    parts.append(sep)

    for year in years:
        cells = [str(year)]
        annual = 1.0
        for m in range(1, 13):
            val = monthly.get((year, m))
            if val is not None:
                annual *= (1 + val / 100)
                cells.append(f"{val:+.1f}%")
            else:
                cells.append("--")
        annual_pct = (annual - 1) * 100
        cells.append(f"**{annual_pct:+.1f}%**")
        parts.append("| " + " | ".join(cells) + " |")

    return "\n".join(parts)


def _cost_breakdown_section(s: dict) -> str:
    """Build cost breakdown as markdown table."""
    costs = [
        ("Commission", s.get("total_commission", 0)),
        ("Spread", s.get("total_spread_cost", 0)),
        ("Market Impact", s.get("total_impact_cost", 0)),
        ("Slippage", s.get("total_slippage_cost", 0)),
        ("Borrow", s.get("total_borrow_cost", 0)),
        ("**Total**", s.get("total_costs", 0)),
    ]

    rows = [
        "\n## Execution Costs\n",
        "| Category | Amount |",
        "|----------|--------|",
    ]
    for label, val in costs:
        rows.append(f"| {label} | ${val:,.2f} |")

    return "\n".join(rows)


def _trade_log_section(trades: list) -> str:
    """Build trade log as markdown table (first 50 trades)."""
    if not trades:
        return "\n## Trade Log\n\n*No trades executed.*\n"

    rows = [
        "\n## Trade Log\n",
        "| Date | Ticker | Side | Shares | Fill | Cost | Signal | Risk |",
        "|------|--------|------|--------|------|------|--------|------|",
    ]

    for t in trades[:50]:
        decision = t.risk_decision[:30] if hasattr(t, "risk_decision") else ""
        rows.append(
            f"| {t.date} | {t.ticker} | {t.side.upper()} | {t.shares:,} "
            f"| ${t.fill_price:.2f} | ${t.total_cost:.2f} "
            f"| {t.signal_score:+.2f} | {decision} |"
        )

    if len(trades) > 50:
        rows.append(f"\n*Showing first 50 of {len(trades):,} trades*")

    return "\n".join(rows)
